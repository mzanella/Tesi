\documentclass[../Tesi.tex]{subfiles}

\begin{document}
	\section{Descrizione delle classi principali}
	Di seguito vengono riportate le descrizioni delle classi più importanti dell'applicazione.

		\subsection{dependency\_injection::AppModule}
		La classe \mclass{AppModule} si occupa della risoluzione delle dipendenze per permettere l'utilizzo della dependency injection. La libreria Dagger 2 utilizza i metodi di questa classe che hanno l'annotazione \textit{@Provides} per l'inizializzazione dei campi dati delle classe con l'annotazione \textit{@Inject}. Nell'applicazione questo meccanismo è utilizzato per far corrispondere per ogni campo dati che ha come tipo un interfaccia, la classe che implementa tale interfaccia.

		\subsection{model::dao::Content}
		La classe \mclass{Content} è utilizzata per la gestione dei contenuti xAPI, di cui l'applicazione deve permettere la fruizione. Gli oggetti di tale classe rappresentano una entry nella relazione \textit{Content} nel database locale, per questo motivo i campi dati di tale classe saranno uguale agli attributi della relazione corrispondente. La classe \mclass{Content} estende la classe \mclass{RealmObject}, fornita dalla libreria Realm. Grazie a ciò è possibile modificare i campi dati di un oggetto di tipo \mclass{Content}, riperquotendo tali modifiche sulla entry corrispondente del database locale. In modo analogo anche le classi \mclass{ContentVersion}, \mclass{LrsData}, \mclass{History} e \mclass{UserData} estendono la classe \mclass{RealmObject}, permettendo quindi la modifica del database.

		\subsection{model::data\_access::DatabaseAccess}
		La classe \mclass{DataAccess} è utilizzata per la gestione dei dati del database riguardanti i contenuti e i dati di fruizione ad essi associati. Tale classe implementa le interfacce \minterface{ContentDataAccess} e \minterface{ContentHistoryForLoggedUserAccess} le quali espongono, rispettivamente, i metodi per l'inserimento, recupero e modifica dei contenuti xAPI trattati dall'applicazione e dei dati di fruizione dell'utente loggato ad esso associati. Tale classe in particolare si occupa di inserire nel database del dispositivo i dati dei contenuti da visualizzare nell'applicazione.

		\subsection{model::data\_access::StatementSenderImp}
		La classe \mclass{StatementSenderImp} si occupa della gestione dell'invio degli statement ottenuti dall'interazione di un utente con i contenuti xAPI al LRS. Tale classe implementa l'interfaccia \minterface{StatementSender}, che a sua volta estende le interfacce \minterface{DatabaseChangeListener} e \minterface{NetworkCHangeListener}. L'interfaccia \minterface{StatementSender} espone i metodi che devono essere implementati al fine di permettere l'invio degli statement ad un LRS. Le interfacce \minterface{DatabaseChangeListener} e \minterface{NetworkCHangeListener} permettono, invece, agli oggetti di tale classe di registrarsi come ``listener'' dei cambiamenti nel database degli statement, gestito dalla libreria TinCanAndroid-Offline, e nella connettività ad internet del dispositivo. Nel caso in cui sia presente una connessione internet e vi siano statement non inviati al LRS tale classe provvederà ad inviarli, eliminandoli dal database della libreria TinCanAndroid-Offline. Per fare questo gli oggetti a tale classe hanno un riferimento ad un oggetto di tipo \mclass{RSTinCanOfflineConnector}. Tale oggetto, della libraria TinCanAndroid-Offline, permette sia l'accesso al database degli statement, sia l'invio di quest'ultimi al LRS.

		\subsection{model::lrs\_access::LrsSynchronizeImp}
		La classe \mclass{LrsSynchronizeImp} si occupa di effettuare delle richieste al LRS per la sincronizzazione dei dati locali. Gli oggetti di questa classe recuperano gli URL per le richieste utilizzando un oggetto di una classe che implementa l'interfaccia \minterface{LrsRequestUrl}. Nel caso sia disponibile una connessiano ad internet, gli oggetti di questa classe si occupano di effettuare le richieste per recuperare le informazioni desiderate dal LRS. Le risposte, che in questa versione dell'applicazione sono in formato JSON, vengono gestite utilizzando la libreria Gson, al fine di recuperarne i dati. Questi dati, se non già presenti nel database locale, vengono utilizzati per aggiornare i dati di fruizione di un utente, utilizzando un oggetto di tipo \minterface{ContentHistoryForLoggedUserAccess}. 

		\subsection{model::result::StartResult}
		La classe \mclass{StartResult} è utilizzata per ricavare le informazioni che vengono inviate dallo script JavaScript che si occupa di ricavare i dati di fruizione di un utente, riguardo all'inizio di un certo contenuto da parte di un utente. Tale classe è generata utilizzando la libreria Google AutoValue. Praticamente questa libreria si occupa di creare il codice delle classi che hanno l'annotazione \textit{@AutoValue}, fornendo anche la possibilità di creare una classe interna ``Builder'', per l'implementazione del design pattern Builder appunto. Il programmatore non deve far altro che dichiarare le classi come astratte e dichiarare i metodi getter per ogni campo dati, anch'essi come astratti, mentre la libreria si occupa della generazione del codice. Le istanze di questa classe vengono create utilizzzando un oggetto \mclass{JsonObject}, il quale contiene le informazioni ricavate dallo script JavaScript, che viene utilizzato per l'inizializzazione dei campi dati del nuovo oggetto. Anche le classi \mclass{PartialResult} e \mclass{TotalResult} sono state create utilizzando la libreria Google AutoValue e hanno scopi simili alla classe \mclass{StartResult}.

		\subsection{model::statement\_object::StartStatementImp}
		La classe \mclasse{StartStatementImp} rappresenta uno statement di inizio di un contenuto da parte di un utente, il quale deve essere inviato ad un LRS. Tale classe implementa l'interfaccia StartStatement e estende l'oggetto \mclass{Statement} della libreria TinCanAndroid-Offline. I campi dello statement relativi a chi ha effettuato l'azione vengono riempiti utilizzando un oggetto di tipo \minterface{UserDataAccess}, il quale permette di accedere ai dati dell'utente loggato. Il campo \textit{verb} viene inizializzato utilizzando la definizione del verbo \texit{inizialized}, disponibile all'URL \url{http://adlnet.gov/expapi/verbs/inizialized}. Infine i campi che definiscono il contesto dello statement e il campo \textit{object} vengono riempiti utilizzando i campi dati di un oggetto \mclass{StartResult}, richiesto dal costruttore della classe. Le classi \mclass{PartialResulStatementImp} e \mclass{TotalResulStatementImp} hanno compiti analoghi e vengono sono costruite in modo simile.

		\subsection{presenter::javascript\_communication::MyJavascriptInterfaceImp}
		La classe \mclass{MyJavascriptInterfaceImp} si occupa di ricevere i dati di fruizione da parte dello script Javascript che ha il compito di recuperare tali informazioni. Tale classe inoltre si occupa di trasformare in statement i dati ricevuti e di inserirli nel database degli statement utilizzando un oggetto \mclass{RSTinCanOfflineConnector}, della libreria TinCanAndroid-Offline. Ad ogni inserimento manda un messaggio in broadcast utilizzando un \mclass{LocalBroadcastManager}, in modo tale che le classi che sono in ascolto di inserimenti all'interno del database degli statement siano avvertite. Per fare ciò implementa l'interfaccia \minterface{MyJavascriptInterface}, i cui metodi che possono essere richiamati dallo script JavaScript sono annotati con \textit{@JavascriptInterface}. Tale annotazione permette di richiamare metodi delle classi di Android da JavaScript, per le versioni uguali o inferiori ad Android 4.2(API level 18). Tale classe, inoltre, ha il compito di aggiornare le informazioni di fruizione dei contenuti xAPI dell'utente loggato in base ai dati ricevuti. 

		\subsection{presenter::manager::DownloaderManagerImp}
		La classe \mclass{DownloaderManagerImp} si occupa del download delle informazioni relative ai contenuti da mostrare nell'appliazione e di rendere disponibili offline i contenuti. Per permettere la fruizione dei contenuti xAPI in modalità offline le istanza di questa classe devono connettersi al server in cui il contenuto risiede e scaricare alcuni file compressi. Questi file vengono decompressi e viene estratto dal loro interno un file in formato XML. Quest'ultimi contengono l'insieme di file di cui deve essere effettuato il download per permettere la fruizione offline del contenuto. Queste informazioni vengono estratte utilizzando delle espressioni in XPath. 

		\subsection{presenter::receiver::InternetStateReceiver}
		La classe \mclass{InternetStateReceiver} 

		\subsection{presenter::MyApplication}

\end{document}